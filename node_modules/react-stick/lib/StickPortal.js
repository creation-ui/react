"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PortalContext = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
require("requestidlecallback");
const invariant_1 = __importDefault(require("invariant"));
const react_1 = require("react");
const react_dom_1 = require("react-dom");
const substyle_1 = require("substyle");
const hooks_1 = require("./hooks");
const utils_1 = require("./utils");
const StickPortal = (0, react_1.forwardRef)(function ({ children, component, style, transportTo, nestingKey, node, position, containerRef, updateOnAnimationFrame, onReposition, ...rest }, ref) {
    const nodeRef = (0, react_1.useRef)();
    const [top, setTop] = (0, react_1.useState)(null);
    const [left, setLeft] = (0, react_1.useState)(null);
    const [visible, setVisible] = (0, react_1.useState)(!!node);
    const [host, hostParent] = useHost(transportTo);
    (0, react_1.useEffect)(() => {
        if (nodeRef.current) {
            onReposition(nodeRef.current);
        }
    }, [onReposition, top, left]);
    (0, react_1.useEffect)(() => {
        setVisible(!!node);
    }, [node]);
    (0, react_1.useLayoutEffect)(() => {
        if (visible) {
            hostParent.appendChild(host);
            return () => {
                hostParent.removeChild(host);
            };
        }
    }, [host, hostParent, visible]);
    const measure = (0, react_1.useCallback)(() => {
        const node = nodeRef.current;
        if (!node || !visible) {
            return;
        }
        const newTop = calculateTop(node, position, host);
        const newLeft = calculateLeft(node, position, host);
        if (newTop !== top) {
            setTop(newTop);
        }
        if (newLeft !== left) {
            setLeft(newLeft);
        }
    }, [host, left, position, top, visible]);
    (0, hooks_1.useWatcher)(measure, { updateOnAnimationFrame, enabled: visible });
    const Component = component || 'div';
    return ((0, jsx_runtime_1.jsxs)(Component, { ...rest, ...style, ref: (node) => {
            if (typeof ref === 'function') {
                ref(node);
            }
            else if (ref) {
                ref.current = node;
            }
            nodeRef.current = node;
        }, children: [children, top != null && left != null && ((0, jsx_runtime_1.jsx)(exports.PortalContext.Provider, { value: (host.parentNode || defaultRoot), children: (0, react_dom_1.createPortal)((0, jsx_runtime_1.jsx)("div", { ref: containerRef, "data-sticknestingkey": nestingKey, ...(0, substyle_1.inline)(style('node'), {
                        position: 'absolute',
                        top,
                        left,
                    }), children: node }), host) }))] }));
});
(0, invariant_1.default)(document.body, 'Stick can only be used in a browser environment.');
const defaultRoot = document.body;
exports.PortalContext = (0, react_1.createContext)(defaultRoot);
exports.default = StickPortal;
function useHost(transportTo) {
    const [host] = (0, react_1.useState)(() => document.createElement('div'));
    const portalHost = (0, react_1.useContext)(exports.PortalContext);
    const hostParent = transportTo || portalHost;
    (0, invariant_1.default)(hostParent, 'Could not determine a parent for the host node.');
    return [host, hostParent];
}
function calculateTop(node, position, host) {
    const { top, height, bottom } = node.getBoundingClientRect();
    const fixedHost = getFixedParent(host);
    let result = 0;
    if (position.indexOf('top') !== -1) {
        result = top;
    }
    if (position.indexOf('middle') !== -1) {
        result = top + height / 2;
    }
    if (position.indexOf('bottom') !== -1) {
        result = bottom;
    }
    if (fixedHost) {
        const { top: hostTop } = fixedHost.getBoundingClientRect();
        return result - hostTop;
    }
    return result + (0, utils_1.scrollY)();
}
function calculateLeft(node, position, host) {
    const { left, width, right } = node.getBoundingClientRect();
    const fixedHost = getFixedParent(host);
    const scrollHost = getScrollParent(node);
    let result = 0;
    if (position.indexOf('left') !== -1) {
        result = left;
    }
    if (position.indexOf('center') !== -1) {
        result = left + width / 2;
    }
    if (position.indexOf('right') !== -1) {
        result = right;
    }
    if (fixedHost) {
        const { left: hostLeft } = fixedHost.getBoundingClientRect();
        return result - hostLeft;
    }
    if (scrollHost) {
        return result + (0, utils_1.scrollX)(node) - scrollHost.scrollLeft;
    }
    return result + (0, utils_1.scrollX)(node);
}
function getScrollParent(element) {
    if (!element) {
        return null;
    }
    if (element.nodeName === 'BODY' || element.nodeName === 'HTML') {
        return null;
    }
    const style = getComputedStyle(element);
    if (style.overflowX === 'auto' || style.overflowX === 'scroll') {
        return element;
    }
    return element.parentNode instanceof Element
        ? getScrollParent(element.parentNode)
        : null;
}
function getFixedParent(element) {
    if (element.nodeName === 'BODY' || element.nodeName === 'HTML') {
        return null;
    }
    if (getComputedStyle(element).position === 'fixed') {
        return element;
    }
    return element.parentNode instanceof Element
        ? getFixedParent(element.parentNode)
        : null;
}
//# sourceMappingURL=StickPortal.js.map