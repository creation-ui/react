"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
require("requestidlecallback");
const invariant_1 = __importDefault(require("invariant"));
const react_1 = require("react");
const substyle_1 = __importDefault(require("substyle"));
const StickContext_1 = require("./StickContext");
const StickInline_1 = __importDefault(require("./StickInline"));
const StickNode_1 = __importDefault(require("./StickNode"));
const StickPortal_1 = __importDefault(require("./StickPortal"));
const defaultPosition_1 = __importDefault(require("./defaultPosition"));
const hooks_1 = require("./hooks");
const utils_1 = require("./utils");
const defaultStyles = {
    node: {
        position: 'absolute',
        zIndex: 99,
        textAlign: 'left',
    },
};
function Stick({ inline = false, node, sameWidth = false, children, updateOnAnimationFrame = false, position, align, component, transportTo, autoFlipHorizontally = false, autoFlipVertically = false, onClickOutside, style, className, classNames, ...rest }) {
    const [width, setWidth] = (0, react_1.useState)(0);
    const [containerNestingKeyExtension] = (0, react_1.useState)(() => (0, utils_1.uniqueId)());
    const nestingKey = [(0, react_1.useContext)(StickContext_1.StickContext), containerNestingKeyExtension]
        .filter((key) => !!key)
        .join('_');
    const anchorRef = (0, react_1.useRef)();
    const nodeRef = (0, react_1.useRef)(null);
    const containerRef = (0, react_1.useRef)();
    const [resolvedPosition, resolvedAlign, checkAlignment] = (0, hooks_1.useAutoFlip)(autoFlipHorizontally, autoFlipVertically, position || defaultPosition_1.default, align || (0, utils_1.getDefaultAlign)(position || defaultPosition_1.default));
    const styles = (0, substyle_1.default)(defaultStyles, { style, className, classNames }, (0, utils_1.getModifiers)({
        position: resolvedPosition,
        align: resolvedAlign,
        sameWidth,
    }));
    (0, react_1.useEffect)(() => {
        const handleScroll = () => {
            if (!nodeRef.current || !anchorRef.current) {
                return;
            }
            checkAlignment(nodeRef.current, anchorRef.current);
        };
        handleScroll(); // Check alignment on first render
        window.addEventListener('scroll', handleScroll);
        return () => {
            window.removeEventListener('scroll', handleScroll);
        };
    }, [checkAlignment]);
    (0, react_1.useEffect)(() => {
        const handleClickOutside = (ev) => {
            if (!onClickOutside) {
                return;
            }
            const { target } = ev;
            if (target instanceof window.HTMLElement &&
                isOutside(anchorRef, containerRef, target)) {
                onClickOutside(ev);
            }
        };
        document.addEventListener('click', handleClickOutside, true);
        return () => {
            document.removeEventListener('click', handleClickOutside, true);
        };
    }, [onClickOutside]);
    const measure = (0, react_1.useCallback)(() => {
        if (!anchorRef.current) {
            return;
        }
        const boundingRect = anchorRef.current.getBoundingClientRect();
        const newWidth = sameWidth
            ? boundingRect.width
            : calculateWidth(anchorRef.current, resolvedPosition, resolvedAlign, boundingRect);
        if (newWidth !== width) {
            setWidth(newWidth);
        }
    }, [resolvedAlign, resolvedPosition, sameWidth, width]);
    (0, hooks_1.useWatcher)(measure, { updateOnAnimationFrame, enabled: !!node });
    const handleReposition = (0, react_1.useCallback)(() => {
        if (nodeRef.current && anchorRef.current) {
            checkAlignment(nodeRef.current, anchorRef.current);
        }
    }, [checkAlignment]);
    if (inline) {
        return ((0, jsx_runtime_1.jsx)(StickContext_1.StickContext.Provider, { value: nestingKey, children: (0, jsx_runtime_1.jsx)(StickInline_1.default, { ...rest, position: resolvedPosition, align: resolvedAlign, style: styles, node: node && ((0, jsx_runtime_1.jsx)(StickNode_1.default, { width: width, position: resolvedPosition, align: resolvedAlign, sameWidth: sameWidth, ref: nodeRef, children: node })), nestingKey: nestingKey, containerRef: (node) => {
                    anchorRef.current = node || undefined;
                    containerRef.current = node || undefined;
                }, component: component, children: children }) }));
    }
    return ((0, jsx_runtime_1.jsx)(StickContext_1.StickContext.Provider, { value: nestingKey, children: (0, jsx_runtime_1.jsx)(StickPortal_1.default, { ...rest, updateOnAnimationFrame: updateOnAnimationFrame, transportTo: transportTo, component: component, ref: (node) => {
                (0, invariant_1.default)(!node || node instanceof Element, 'Only HTML elements can be stick anchors.');
                anchorRef.current = node || undefined;
            }, position: resolvedPosition, node: node && ((0, jsx_runtime_1.jsx)(StickNode_1.default, { width: width, position: resolvedPosition, align: resolvedAlign, sameWidth: sameWidth, ref: nodeRef, children: node })), style: styles, nestingKey: nestingKey, containerRef: containerRef, onReposition: handleReposition, children: children }) }));
}
function isOutside(anchorRef, containerRef, target) {
    if (anchorRef.current && anchorRef.current.contains(target)) {
        return false;
    }
    const nestingKey = containerRef.current &&
        containerRef.current.getAttribute('data-sticknestingkey');
    if (nestingKey) {
        // Find all stick nodes nested inside our own stick node and check if the click
        // happened on any of these (our own stick node will also be part of the query result)
        const nestedStickNodes = document.querySelectorAll(`[data-stickNestingKey^='${nestingKey}']`);
        return (!nestedStickNodes ||
            !Array.from(nestedStickNodes).some((stickNode) => stickNode.contains(target)));
    }
    return true;
}
function calculateWidth(anchorRef, position, align, { left, width, right }) {
    if (!anchorRef) {
        return 0;
    }
    (0, invariant_1.default)(document.documentElement, 'Could not find document root node.');
    const scrollWidth = document.documentElement.scrollWidth;
    const [, horizontalPosition] = position.split(' ');
    (0, invariant_1.default)(horizontalPosition === 'left' ||
        horizontalPosition === 'center' ||
        horizontalPosition === 'right', `Expected horizontal position to be "left", "center", or "right" but got "${horizontalPosition}".`);
    const positionAdjustments = {
        left,
        center: left + width / 2,
        right,
    };
    const absLeft = (0, utils_1.scrollX)(anchorRef) + positionAdjustments[horizontalPosition];
    if (align.indexOf('left') !== -1) {
        return scrollWidth - absLeft;
    }
    if (align.indexOf('right') !== -1) {
        return absLeft;
    }
    if (align.indexOf('center') !== -1) {
        return Math.min(absLeft, scrollWidth - absLeft) * 2;
    }
    return 0;
}
exports.default = Stick;
//# sourceMappingURL=Stick.js.map